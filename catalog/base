#!/bin/bash
#
# UNMM Base Catalog
# Sob licença MIT
#
# Criador: João Paulo (o Jppgmx)
#

CATALOG_NAME="base"
CATALOG_DISPLAY_NAME="Base Catalog"
CATALOG_VERSION="1.0.0"
CATALOG_DESCRIPTION="Base de todo o catálogo."
CATALOG_PREFFERED_SIZE="4G"

_BASE_SYSTEM_PACKAGES_ESSENTIALS=(
    "linux-image-generic" "linux-firmware" "initramfs-tools" "zstd"
    "netplan.io" "systemd-resolved"
    "locales" "console-setup"
    "sudo" "nano" "bash-completion"
    "software-properties-common" "ca-certificates" "wget" "gnupg"
    "haveged"
)
_BASE_SYSTEM_ARCHITECTURE_SUPPORTED="amd64"
_BASE_SYSTEM_UBUNTU_MIRROR="http://archive.ubuntu.com/ubuntu"
_BASE_SYSTEM_UBUNTU_CODENAME="noble"
_BASE_SYSTEM_PREFERRED_SWAP_SIZE="2G"
_BASE_SYSTEM_UBUNTU_SOURCES_LIST=(
    "deb http://archive.ubuntu.com/ubuntu noble main restricted universe multiverse"
    "deb http://archive.ubuntu.com/ubuntu noble-updates main restricted universe multiverse"
    "deb http://security.ubuntu.com/ubuntu noble-security main restricted universe multiverse"
)
_BASE_SYSTEM_DEBCONF_DEFAULTS=(
    "locales locales/default_environment_locale select pt_BR.UTF-8"
    "locales locales/locales_to_be_generated multiselect pt_BR.UTF-8 UTF-8"
    "console-setup console-setup/layoutcode select br"
    "console-setup console-setup/modelcode string pc105"
    "console-setup console-setup/variantcode string "
    "console-setup console-setup/charmap47 select UTF-8"
)

# _base_deboostrap <mountpoint> <suite> <mirror>
# Executa o debootstrap para criar o sistema base.
# 
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema será instalado.
#   suite      - Nome da suíte do Ubuntu (ex: noble, focal).
#   mirror     - URL do espelho do Ubuntu a ser usado.
_base_deboostrap() {
    local mountpoint="$1"
    local suite="$2"
    local mirror="$3"

    log_info "Executando debootstrap no ponto de montagem $mountpoint..."
    if ! exec_logged "debootstrap" debootstrap --arch="$_BASE_SYSTEM_ARCHITECTURE_SUPPORTED" --variant=minbase \
        "$suite" "$mountpoint" "$mirror"; then
        log_error "Falha ao executar o debootstrap."
        exit 1
    fi
}

# _base_write_swapfile <mountpoint> <size>
# Cria um swapfile no sistema instalado e retorna a linha para o fstab.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
#   size       - Tamanho do swapfile (ex: 2G, 512M).
#
# Retorna:
#   Linha a ser adicionada ao fstab para o swapfile.
_base_write_swapfile() {
    local mountpoint="$1"
    local size="$2"
    local swapfile_path="$mountpoint/swapfile"

    log_info "Criando swapfile de tamanho $size em $swapfile_path"
    chroot_call_logged "$mountpoint" fallocate -l "$size" /swapfile
    chroot_call_logged "$mountpoint" chmod 600 /swapfile
    chroot_call_logged "$mountpoint" mkswap /swapfile
    chroot_call_logged "$mountpoint" swapon /swapfile

    echo '/swapfile none swap sw 0 0'
}

# _base_write_fstab_file <mountpoint> [additional lines...]
# Escreve o arquivo /etc/fstab padrão no sistema instalado com base nas partições criadas.
#
# Argumentos:
#   mountpoint       - Ponto de montagem onde o sistema está instalado.
#   additional lines - Linhas adicionais válidas para adicionar ao final do fstab.
_base_write_fstab_file() {
    local mountpoint="$1"
    local fstab_path="$mountpoint/etc/fstab"

    log_info "Escrevendo arquivo fstab em $fstab_path"
    local fstab_lines=(
        "# /etc/fstab: static file system information."
        "# Gerado por UNMM. Não edite manualmente (a menos se for necessário)."
        "# <file system> <mount point>   <type>  <options>       <dump>  <pass>"
    )

    rm -f "$fstab_path"
    
    local schema partitions system_partition system_uuid

    schema=$(diskpart_get_disk_partition_schema "$CATALOG_INSTALL_ARG_DEVICE")
    partitions=$(diskpart_get_partitions "$CATALOG_INSTALL_ARG_DEVICE")
    system_partition="${CATALOG_INSTALL_ARG_DEVICE}p$(echo "$partitions" | grep ext4 | cut -d';' -f1 | cut -d'=' -f2)"
    system_uuid=$(blkid -s UUID -o value "$system_partition")

    fstab_lines+=("UUID=$system_uuid / ext4 defaults 0 1")

    if [[ "$schema" == "gpt" ]]; then
        local efi_partition efi_uuid
        efi_partition="${CATALOG_INSTALL_ARG_DEVICE}p$(echo "$partitions" | grep esp | cut -d';' -f1 | cut -d'=' -f2)"
        efi_uuid=$(blkid -s UUID -o value "$efi_partition")

        fstab_lines+=("UUID=$efi_uuid /boot/efi vfat defaults 0 1")
    fi

    for line in "${fstab_lines[@]}"; do
        log_verbose "Escrevendo linha no fstab: $line"
        echo "$line" >> "$fstab_path"
    done

    shift
    for additional_line in "$@"; do
        log_verbose "Escrevendo linha adicional no fstab: $additional_line"
        echo "$additional_line" >> "$fstab_path"
    done
}

# _base_write_ubuntu_sources_list <mountpoint> [extra sources...]
# Escreve o arquivo /etc/apt/sources.list no sistema instalado.
#
# Argumentos:
#   mountpoint    - Ponto de montagem onde o sistema está instalado.
#   extra sources - Repositórios adicionais a serem adicionados ao final do sources.list.
_base_write_ubuntu_sources_list() {
    local mountpoint="$1"
    local sources_list_path="$mountpoint/etc/apt/sources.list"
    log_info "Escrevendo arquivo sources.list em $sources_list_path"
    rm -f "$sources_list_path"
    for source in "${_BASE_SYSTEM_UBUNTU_SOURCES_LIST[@]}"; do
        log_verbose "Adicionando repositório ao sources.list: $source"
        echo "$source" >> "$sources_list_path"
    done

    shift
    for extra_source in "$@"; do
        log_verbose "Adicionando repositório extra ao sources.list: $extra_source"
        echo "$extra_source" >> "$sources_list_path"
    done
}

# _apt_update <mountpoint>
# Atualiza os repositórios do sistema no ponto de montagem especificado.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
_base_apt_update() {
    local mountpoint="$1"

    log_info "Atualizando repositórios do sistema..."
    if ! chroot_call_logged "$mountpoint" apt-get update; then
        log_error "Falha ao atualizar os repositórios do sistema."
        exit 1
    fi
}

# _base_install_essentials <mountpoint>
# Instala os pacotes essenciais do sistema no ponto de montagem especificado com base na variável _BASE_SYSTEM_PACKAGES_ESSENTIALS.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
_base_install_essentials() {
    local mountpoint="$1"

    log_info "Instalando pacotes essenciais do sistema..."

    #shellcheck disable=SC2086
    if ! chroot_call_logged "$mountpoint" $APT_GET_COMMAND "${_BASE_SYSTEM_PACKAGES_ESSENTIALS[@]}"; then
        log_error "Falha ao instalar pacotes essenciais do sistema."
        exit 1
    fi
}

# _base_set_hostname <mountpoint> <hostname>
# Configura o hostname do sistema no ponto de montagem especificado.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
#   hostname   - Nome do host a ser configurado.
_base_set_hostname() {
    local mountpoint="$1"
    local hostname="$2"

    log_info "Configurando hostname para '$hostname' em $mountpoint/etc/hostname"
    echo "$hostname" > "$mountpoint/etc/hostname"

    log_info "Atualizando arquivo /etc/hosts..."
    cat > "$mountpoint/etc/hosts" <<EOF
127.0.0.1 localhost
127.0.1.1 $hostname
EOF
}

# _base_link_resolv_conf <mountpoint>
# Configura o link simbólico para /etc/resolv.conf apontando para o systemd-resolved.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
_base_link_resolv_conf() {
    local mountpoint="$1"

    log_info "Configurando link simbólico para /etc/resolv.conf..."
    chroot_call_logged "$mountpoint" ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
    chroot_call_logged "$mountpoint" systemctl enable systemd-resolved
}

# _base_configure_netplan_default <mountpoint>
# Configura o netplan para usar DHCP na interface enp0s3 por padrão.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
_base_configure_netplan_default() {
    local mountpoint="$1"

    log_info "Configurando netplan para conexão DHCP padrão..."
    cat > "$mountpoint/etc/netplan/01-netcfg.yaml" <<EOF
network:
  version: 2
  ethernets:
    enp0s3:
      dhcp4: true
EOF
}

# _configure_user <mountpoint> <username> <password>
# Configura o usuário padrão no sistema instalado.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
#   username   - Nome do usuário a ser criado.
#   password   - Senha do usuário a ser criado.
_base_configure_user() {
    local mountpoint="$1"
    local username="$2"
    local password="$3"

    log_info "Criando usuário '$username' com privilégios sudo..."
    chroot_call_logged "$mountpoint" useradd -m -s /bin/bash -G sudo "$username"
    echo "$username:$password" | chroot_call_logged "$mountpoint" "chpasswd"
    echo "root:root" | chroot_call_logged "$mountpoint" "chpasswd"
}

# _grub_install <mountpoint> <device>
# Instala e configura o GRUB no sistema instalado.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
#   device     - Dispositivo de bloco onde o sistema está instalado.
#   bootmode   - Modo de boot (bios, uefi, hybrid).
_base_grub_install() {
    local mountpoint="$1"
    local device="$2"
    local bootmode="$3"
    
    local grub_packages=()
    local grub_targets_install=()

    log_info "Determinando a forma de instalação do GRUB..."
    if [[ "$bootmode" == "uefi" || "$bootmode" == "hybrid" ]]; then
        if [[ "$bootmode" == "hybrid" ]]; then
            grub_packages+=("grub-efi-amd64-bin" "shim-signed")
        else
            grub_packages+=("grub-efi-amd64" "shim-signed")
        fi
        grub_targets_install+=(
            "EFI: --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=GRUB --recheck --no-floppy --no-nvram"
        )
    fi

    if [[ "$bootmode" == "bios" || "$bootmode" == "hybrid" ]]; then
        grub_packages+=("grub-pc")
        grub_targets_install+=(
            "BIOS: --target=i386-pc --recheck --no-floppy $device"
        )
    fi

    log_verbose "Instalando pacotes do GRUB: ${grub_packages[*]}"
    for target in "${grub_targets_install[@]}"; do
        IFS=": " read -r desc grub_command <<< "$target"
        log_verbose "Preparando instalação do GRUB para $desc com comando: grub-install $grub_command"
    done

    log_info "Instalando pacotes do GRUB..."

    #shellcheck disable=SC2086
    if ! chroot_call_logged "$mountpoint" $APT_GET_COMMAND "${grub_packages[@]}"; then
        log_error "Falha ao instalar pacotes do GRUB."
        exit 1
    fi

    for target in "${grub_targets_install[@]}"; do
        IFS=": " read -r desc grub_command <<< "$target"

        log_info "Instalando o GRUB para $desc..."

        #shellcheck disable=SC2086
        if ! chroot_call_logged "$mountpoint" grub-install $grub_command; then
            log_error "Falha ao instalar o GRUB para $desc."
            exit 1
        fi
    done

    log_info "Gerando initramfs..."
    chroot_call_logged "$mountpoint" update-initramfs -u -k all

    log_info "Atualizando configuração do GRUB..."
    chroot_call_logged "$mountpoint" update-grub
}

# _base_write_startup_script <mountpoint>
# Escreve o script de inicialização do First Boot no sistema instalado.
#
# Argumentos:
#   mountpoint - Ponto de montagem onde o sistema está instalado.
_base_write_startup_script() {
    local mountpoint="$1"

    log_info "Instalando script de inicialização do First Boot..."
    local fbm_dir="$ASSETS_DIR/firstboot-manager"
    local files=(
        "firstboot-manager.sh:/usr/local/bin/firstboot-manager.sh"
        "firstboot.service:/etc/systemd/system/firstboot.service"
    )
    for file in "${files[@]}"; do
        IFS=":" read -r src dest <<< "$file"

        log_verbose "Copiando $src para $dest"
        cp "$fbm_dir/$src" "$mountpoint$dest"
    done

    log_verbose "Criando diretório de scripts..."
    mkdir -p "$mountpoint/opt/firstboot.d"

    log_verbose "Habilitando serviço firstboot.service..."
    chroot_call_logged "$mountpoint" systemctl enable firstboot.service
}

# _base_install
# Combina todas as etapas para instalar o sistema base no ponto de montagem especificado.
# Este é o núcleo da instalação do catálogo "base".
_base_install() {
    export DEBIAN_FRONTEND=noninteractive
    log_info "Preparando instalação do catálogo $CATALOG_NAME..."

    chroot_mount_system "$CATALOG_INSTALL_ARG_DEVICE" "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    _base_deboostrap "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$_BASE_SYSTEM_UBUNTU_CODENAME" "$_BASE_SYSTEM_UBUNTU_MIRROR"

    log_info "Instalação básica do catálogo $CATALOG_NAME concluída."
    log_info "Preparando ambiente chroot para próxima etapa..."

    chroot_prepare_environment "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    log_info "Ambiente chroot preparado."

    local swap_line
    swap_line=$(_base_write_swapfile "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$_BASE_SYSTEM_PREFERRED_SWAP_SIZE")
    _base_write_fstab_file "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$swap_line"

    log_warning "AVISO: Algumas saídas normais do APT são imprimidas no stderr, podendo parecer que há erros quando não há."

    log_info "Atualizando repositórios do sistema..."
    log_verbose "Escrevendo sources.list personalizado..."
    _base_write_ubuntu_sources_list "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    _base_apt_update "$CATALOG_INSTALL_ARG_MOUNTPOINT"

    log_verbose "Instalando debconf-utils para configuração de pacotes..."

    #shellcheck disable=SC2086
    if ! chroot_call_logged "$CATALOG_INSTALL_ARG_MOUNTPOINT" $APT_GET_COMMAND debconf-utils; then
        log_error "Falha ao instalar debconf-utils."
        exit 1
    fi

    log_info "Configurando valores padrão do debconf..."
    for debconf_entry in "${_BASE_SYSTEM_DEBCONF_DEFAULTS[@]}"; do
        log_verbose "Configurando debconf: $debconf_entry"
        if ! echo "$debconf_entry" | chroot_call_logged "$CATALOG_INSTALL_ARG_MOUNTPOINT" "debconf-set-selections"; then
            log_error "Falha ao configurar debconf: $debconf_entry"
            exit 1
        fi
    done

    _base_install_essentials "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    _base_link_resolv_conf "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    _base_configure_netplan_default "$CATALOG_INSTALL_ARG_MOUNTPOINT"
    _base_set_hostname "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$CATALOG_INSTALL_ARG_HOSTNAME"
    _base_configure_user "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$CATALOG_INSTALL_ARG_USERNAME" "$CATALOG_INSTALL_ARG_PASSWORD"
    _base_grub_install "$CATALOG_INSTALL_ARG_MOUNTPOINT" "$CATALOG_INSTALL_ARG_DEVICE" "$CATALOG_INSTALL_ARG_BOOTMODE"
    _base_write_startup_script "$CATALOG_INSTALL_ARG_MOUNTPOINT"

    log_info "Instalação do catálogo $CATALOG_NAME concluída."
}


#   Argumentos globais:
#
# CATALOG_INSTALL_ARG_DEVICE        - Dispositivo de bloco onde a imagem está montada.
# CATALOG_INSTALL_ARG_MOUNTPOINT    - Ponto de montagem do sistema de arquivos raiz.
# CATALOG_INSTALL_ARG_HOSTNAME      - Nome do host a ser configurado.
# CATALOG_INSTALL_ARG_USERNAME      - Nome do usuário a ser criado.
# CATALOG_INSTALL_ARG_PASSWORD      - Senha do usuário a ser criado.
# CATALOG_INSTALL_ARG_BOOTMODE      - Modo de boot (bios, uefi, hybrid).
# CATALOG_INSTALL_ARG_DISKIMAGEPATH - Caminho para a imagem de disco.
# CATALOG_INSTALL_ARG_SIZE          - Tamanho da imagem de disco.
#
catalog_install() {
    _base_install
}